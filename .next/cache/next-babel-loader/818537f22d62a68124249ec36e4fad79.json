{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport Ceramic from '@ceramicnetwork/http-client';\nimport { IDX } from '@ceramicstudio/idx';\nimport { Ed25519Provider } from 'key-did-provider-ed25519';\nimport { definitions } from \"../utils/config.json\";\nimport { BigNumber, utils, ethers } from 'ethers';\nimport { hashSync } from 'bcryptjs';\nvar CERAMIC_URL = 'https://ceramic.signchain.xyz';\nexport var generateIDX = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(seed) {\n    var ceramic, idx;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n\n            if (!seed) {\n              _context.next = 9;\n              break;\n            }\n\n            ceramic = new Ceramic(CERAMIC_URL);\n            _context.next = 5;\n            return ceramic.setDIDProvider(new Ed25519Provider(seed));\n\n          case 5:\n            // Create the IDX instance with the definitions aliases from the config\n            idx = new IDX({\n              ceramic: ceramic,\n              aliases: definitions\n            });\n            return _context.abrupt(\"return\", {\n              idx: idx,\n              ceramic: ceramic\n            });\n\n          case 9:\n            return _context.abrupt(\"return\", {\n              idx: null,\n              ceramic: null\n            });\n\n          case 10:\n            _context.next = 16;\n            break;\n\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](0);\n            console.log(_context.t0);\n            return _context.abrupt(\"return\", {\n              idx: null,\n              ceramic: null\n            });\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 12]]);\n  }));\n\n  return function generateIDX(_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); // export const generateIDXForMagic = async (provider) => {\n//   // avoid sending the raw secret by hashing it first\n//   try{\n//     if(provider){\n//       const ceramic = new Ceramic(CERAMIC_URL)\n//       await ceramic.setDIDProvider(new Ed25519Provider(seed))\n//       // Create the IDX instance with the definitions aliases from the config\n//       const idx = new IDX({ ceramic, aliases: definitions })\n//       console.log(idx);\n//       return {idx, ceramic, seed}\n//     }else{\n//       return {idx: null, ceramic: null, seed: null}\n//     }\n//   }catch(error){\n//       console.log(error)\n//       return {idx: null, ceramic: null, seed: null}\n//   }\n// }","map":{"version":3,"sources":["D:/identity-managment/lib/identity.js"],"names":["Ceramic","IDX","Ed25519Provider","definitions","BigNumber","utils","ethers","hashSync","CERAMIC_URL","generateIDX","seed","ceramic","setDIDProvider","idx","aliases","console","log"],"mappings":";;AAAA,OAAOA,OAAP,MAAoB,6BAApB;AACA,SAAQC,GAAR,QAAkB,oBAAlB;AACA,SAAQC,eAAR,QAA8B,0BAA9B;AACA,SAAQC,WAAR,QAA0B,sBAA1B;AACA,SAASC,SAAT,EAAoBC,KAApB,EAA2BC,MAA3B,QAAyC,QAAzC;AACA,SAASC,QAAT,QAAyB,UAAzB;AAEA,IAAMC,WAAW,GAAG,+BAApB;AAGA,OAAO,IAAMC,WAAW;AAAA,sEAAG,iBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,iBAGlBA,IAHkB;AAAA;AAAA;AAAA;;AAIbC,YAAAA,OAJa,GAIH,IAAIX,OAAJ,CAAYQ,WAAZ,CAJG;AAAA;AAAA,mBAKbG,OAAO,CAACC,cAAR,CAAuB,IAAIV,eAAJ,CAAoBQ,IAApB,CAAvB,CALa;;AAAA;AAMnB;AACMG,YAAAA,GAPa,GAOP,IAAIZ,GAAJ,CAAQ;AAAEU,cAAAA,OAAO,EAAPA,OAAF;AAAWG,cAAAA,OAAO,EAAEX;AAApB,aAAR,CAPO;AAAA,6CAQZ;AAACU,cAAAA,GAAG,EAAHA,GAAD;AAAMF,cAAAA,OAAO,EAAPA;AAAN,aARY;;AAAA;AAAA,6CAUZ;AAACE,cAAAA,GAAG,EAAE,IAAN;AAAYF,cAAAA,OAAO,EAAE;AAArB,aAVY;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAanBI,YAAAA,OAAO,CAACC,GAAR;AAbmB,6CAcZ;AAACH,cAAAA,GAAG,EAAE,IAAN;AAAYF,cAAAA,OAAO,EAAE;AAArB,aAdY;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAXF,WAAW;AAAA;AAAA;AAAA,GAAjB,C,CAqBL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA","sourcesContent":["import Ceramic from '@ceramicnetwork/http-client'\r\nimport {IDX} from '@ceramicstudio/idx'\r\nimport {Ed25519Provider} from 'key-did-provider-ed25519'\r\nimport {definitions} from \"../utils/config.json\"\r\nimport { BigNumber, utils, ethers } from 'ethers'\r\nimport { hashSync } from 'bcryptjs'\r\n\r\nconst CERAMIC_URL = 'https://ceramic.signchain.xyz'\r\n\r\n\r\nexport const generateIDX = async (seed) => {\r\n    // avoid sending the raw secret by hashing it first\r\n    try{\r\n      if(seed){\r\n        const ceramic = new Ceramic(CERAMIC_URL)\r\n        await ceramic.setDIDProvider(new Ed25519Provider(seed))\r\n        // Create the IDX instance with the definitions aliases from the config\r\n        const idx = new IDX({ ceramic, aliases: definitions })\r\n        return {idx, ceramic}\r\n      }else{\r\n        return {idx: null, ceramic: null}\r\n      }\r\n    }catch(error){\r\n        console.log(error)\r\n        return {idx: null, ceramic: null}\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  // export const generateIDXForMagic = async (provider) => {\r\n  //   // avoid sending the raw secret by hashing it first\r\n  //   try{\r\n  //     if(provider){\r\n  //       const ceramic = new Ceramic(CERAMIC_URL)\r\n  //       await ceramic.setDIDProvider(new Ed25519Provider(seed))\r\n  //       // Create the IDX instance with the definitions aliases from the config\r\n  //       const idx = new IDX({ ceramic, aliases: definitions })\r\n  //       console.log(idx);\r\n  //       return {idx, ceramic, seed}\r\n  //     }else{\r\n  //       return {idx: null, ceramic: null, seed: null}\r\n  //     }\r\n      \r\n  //   }catch(error){\r\n  //       console.log(error)\r\n  //       return {idx: null, ceramic: null, seed: null}\r\n  //   }\r\n\r\n  // }\r\n"]},"metadata":{},"sourceType":"module"}