{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { BigNumber, providers, utils } from 'ethers';\nimport { hashSync } from 'bcryptjs';\n\nvar generateMessageForEntropy = function generateMessageForEntropy(ethereum_address, application_name) {\n  return '******************************************************************************** \\n' + 'READ THIS MESSAGE CAREFULLY. \\n' + 'DO NOT SHARE THIS SIGNED MESSAGE WITH ANYONE OR THEY WILL HAVE READ AND WRITE \\n' + 'ACCESS TO THIS APPLICATION. \\n' + 'DO NOT SIGN THIS MESSAGE IF THE FOLLOWING IS NOT TRUE OR YOU DO NOT CONSENT \\n' + 'TO THE CURRENT APPLICATION HAVING ACCESS TO THE FOLLOWING APPLICATION. \\n' + '******************************************************************************** \\n' + 'The Ethereum address used by this application is: \\n' + '\\n' + ethereum_address.value + '\\n' + '\\n' + '\\n' + 'By signing this message, you authorize the current application to use the \\n' + 'following app associated with the above address: \\n' + '\\n' + application_name + '\\n' + '\\n' + '\\n' + 'The hash of your non-recoverable, private, non-persisted password or secret \\n' + 'phrase is: \\n' + '\\n' + '\\n' + '\\n' + '\\n' + '******************************************************************************** \\n' + 'ONLY SIGN THIS MESSAGE IF YOU CONSENT TO THE CURRENT PAGE ACCESSING THE KEYS \\n' + 'ASSOCIATED WITH THE ABOVE ADDRESS AND APPLICATION. \\n' + 'AGAIN, DO NOT SHARE THIS SIGNED MESSAGE WITH ANYONE OR THEY WILL HAVE READ AND \\n' + 'WRITE ACCESS TO THIS APPLICATION. \\n' + '******************************************************************************** \\n';\n};\n\nvar getSigner = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var provider, signer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (window.ethereum) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new Error('Ethereum is not connected. Please download Metamask from https://metamask.io/download.html');\n\n          case 2:\n            console.debug('Initializing web3 provider...');\n            provider = new providers.Web3Provider(window.ethereum);\n            signer = provider.getSigner();\n            return _context.abrupt(\"return\", signer);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getSigner() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport var getProvider = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var provider;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (window.ethereum) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new Error('Ethereum is not connected. Please download Metamask from https://metamask.io/download.html');\n\n          case 2:\n            console.debug('Initializing web3 provider...');\n            window.ethereum.enable();\n            provider = new providers.Web3Provider(window.ethereum);\n            return _context2.abrupt(\"return\", provider);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getProvider() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar getAddressAndSigner = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var signer, accounts, address;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return getSigner();\n\n          case 2:\n            signer = _context3.sent;\n            _context3.next = 5;\n            return window.ethereum.request({\n              method: 'eth_requestAccounts'\n            });\n\n          case 5:\n            accounts = _context3.sent;\n\n            if (!(accounts.length === 0)) {\n              _context3.next = 8;\n              break;\n            }\n\n            throw new Error('No account is provided. Please provide an account to this application.');\n\n          case 8:\n            address = accounts[0];\n            return _context3.abrupt(\"return\", {\n              address: address,\n              signer: signer\n            });\n\n          case 10:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function getAddressAndSigner() {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexport var generateSignature = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(web3Provider) {\n    var signedText, providerUsed, signer, userAddress, message, metamask, _message, hash, seed;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!web3Provider) {\n              _context4.next = 12;\n              break;\n            }\n\n            signer = web3Provider.getSigner();\n            _context4.next = 4;\n            return signer.getAddress();\n\n          case 4:\n            userAddress = _context4.sent;\n            message = generateMessageForEntropy(userAddress, 'Portex');\n            _context4.next = 8;\n            return signer.signMessage(message);\n\n          case 8:\n            signedText = _context4.sent;\n            providerUsed = web3Provider;\n            _context4.next = 20;\n            break;\n\n          case 12:\n            _context4.next = 14;\n            return getAddressAndSigner();\n\n          case 14:\n            metamask = _context4.sent;\n            _message = generateMessageForEntropy(metamask.address, 'Portex');\n            _context4.next = 18;\n            return metamask.signer.signMessage(_message);\n\n          case 18:\n            signedText = _context4.sent;\n            providerUsed = metamask;\n\n          case 20:\n            hash = utils.keccak256(signedText);\n            seed = hash // @ts-ignore\n            .replace('0x', '') // @ts-ignore\n            .match(/.{2}/g).map(function (hexNoPrefix) {\n              return BigNumber.from('0x' + hexNoPrefix).toNumber();\n            });\n            return _context4.abrupt(\"return\", {\n              seed: seed,\n              providerUsed: providerUsed\n            });\n\n          case 23:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function generateSignature(_x) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["D:/identity-managment/lib/signerConnect.js"],"names":["BigNumber","providers","utils","hashSync","generateMessageForEntropy","ethereum_address","application_name","value","getSigner","window","ethereum","Error","console","debug","provider","Web3Provider","signer","getProvider","enable","getAddressAndSigner","request","method","accounts","length","address","generateSignature","web3Provider","getAddress","userAddress","message","signMessage","signedText","providerUsed","metamask","hash","keccak256","seed","replace","match","map","hexNoPrefix","from","toNumber"],"mappings":"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","sourcesContent":["import { BigNumber, providers, utils } from 'ethers'\r\nimport { hashSync } from 'bcryptjs'\r\n\r\nconst generateMessageForEntropy = (ethereum_address, application_name) => {\r\n    return (\r\n      '******************************************************************************** \\n' +\r\n      'READ THIS MESSAGE CAREFULLY. \\n' +\r\n      'DO NOT SHARE THIS SIGNED MESSAGE WITH ANYONE OR THEY WILL HAVE READ AND WRITE \\n' +\r\n      'ACCESS TO THIS APPLICATION. \\n' +\r\n      'DO NOT SIGN THIS MESSAGE IF THE FOLLOWING IS NOT TRUE OR YOU DO NOT CONSENT \\n' +\r\n      'TO THE CURRENT APPLICATION HAVING ACCESS TO THE FOLLOWING APPLICATION. \\n' +\r\n      '******************************************************************************** \\n' +\r\n      'The Ethereum address used by this application is: \\n' +\r\n      '\\n' +\r\n      ethereum_address.value +\r\n      '\\n' +\r\n      '\\n' +\r\n      '\\n' +\r\n      'By signing this message, you authorize the current application to use the \\n' +\r\n      'following app associated with the above address: \\n' +\r\n      '\\n' +\r\n      application_name +\r\n      '\\n' +\r\n      '\\n' +\r\n      '\\n' +\r\n      'The hash of your non-recoverable, private, non-persisted password or secret \\n' +\r\n      'phrase is: \\n' +\r\n      '\\n' +\r\n      '\\n' +\r\n      '\\n' +\r\n      '\\n' +\r\n      '******************************************************************************** \\n' +\r\n      'ONLY SIGN THIS MESSAGE IF YOU CONSENT TO THE CURRENT PAGE ACCESSING THE KEYS \\n' +\r\n      'ASSOCIATED WITH THE ABOVE ADDRESS AND APPLICATION. \\n' +\r\n      'AGAIN, DO NOT SHARE THIS SIGNED MESSAGE WITH ANYONE OR THEY WILL HAVE READ AND \\n' +\r\n      'WRITE ACCESS TO THIS APPLICATION. \\n' +\r\n      '******************************************************************************** \\n'\r\n    );\r\n  }\r\n\r\n  const getSigner = async () => {\r\n    if (!window.ethereum) {\r\n      throw new Error(\r\n        'Ethereum is not connected. Please download Metamask from https://metamask.io/download.html'\r\n      );\r\n    }\r\n\r\n    console.debug('Initializing web3 provider...');\r\n    const provider = new providers.Web3Provider(window.ethereum);\r\n    const signer = provider.getSigner();\r\n    return signer\r\n  }\r\n\r\n  export const getProvider = async () => {\r\n    if (!window.ethereum) {\r\n      throw new Error(\r\n        'Ethereum is not connected. Please download Metamask from https://metamask.io/download.html'\r\n      );\r\n    }\r\n\r\n    console.debug('Initializing web3 provider...');\r\n    window.ethereum.enable()\r\n    const provider = new providers.Web3Provider(window.ethereum);\r\n    return provider\r\n  }\r\n\r\n  const getAddressAndSigner = async() => {\r\n    const signer = await getSigner()\r\n    // @ts-ignore\r\n    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\r\n    if (accounts.length === 0) {\r\n      throw new Error('No account is provided. Please provide an account to this application.');\r\n    }\r\n    const address = accounts[0];\r\n    return {address, signer}\r\n  }\r\n\r\n  export const generateSignature = async (web3Provider) => {\r\n    let signedText;\r\n    let providerUsed;\r\n    if(web3Provider){\r\n      const signer = web3Provider.getSigner();\r\n      const userAddress = await signer.getAddress();\r\n      const message = generateMessageForEntropy(userAddress, 'Portex')\r\n      signedText = await signer.signMessage(message);\r\n      providerUsed = web3Provider\r\n    }\r\n    else{\r\n      const metamask = await getAddressAndSigner()\r\n      const message = generateMessageForEntropy(metamask.address, 'Portex')\r\n      signedText = await metamask.signer.signMessage(message);\r\n      providerUsed = metamask\r\n    }\r\n    \r\n    const hash = utils.keccak256(signedText);\r\n    const seed = hash\r\n      // @ts-ignore\r\n      .replace('0x', '')\r\n      // @ts-ignore\r\n      .match(/.{2}/g)\r\n      .map((hexNoPrefix) => BigNumber.from('0x' + hexNoPrefix).toNumber())\r\n    return {seed, providerUsed}\r\n  }"]},"metadata":{},"sourceType":"module"}