{"ast":null,"code":"const crypto = require('crypto');\n\nconst {\n  Client,\n  Where,\n  ThreadID\n} = require('@textile/hub');\n\nconst io = require('socket.io-client');\n\nexport const solveChallenge = identity => {\n  return new Promise((resolve, reject) => {\n    const socket = io(process.env.NEXT_PUBLIC_MIDDLEWARE_URL);\n    socket.on(\"connect\", () => {\n      const publicKey = identity.public.toString(); // Send public key to server\n\n      socket.emit('authInit', JSON.stringify({\n        pubKey: publicKey,\n        type: 'token'\n      }));\n      socket.on(\"authMsg\", async event => {\n        const data = JSON.parse(event);\n\n        switch (data.type) {\n          case 'error':\n            {\n              reject(data.value);\n              break;\n            }\n          //solve the challenge\n\n          case 'challenge':\n            {\n              const buf = Buffer.from(data.value);\n              const signed = await identity.sign(buf);\n              socket.emit(\"challengeResp\", signed);\n              break;\n            }\n          //get the token and store it\n\n          case 'token':\n            {\n              resolve(data.value);\n              socket.disconnect();\n              break;\n            }\n        }\n      });\n    });\n  });\n};\nexport const loginUserWithChallenge = async function (id) {\n  if (!id) {\n    throw Error('No user ID found');\n  }\n  /** Use the identity to request a new API token when needed */\n\n\n  const credentials = await solveChallenge(id);\n  localStorage.setItem('payload', JSON.stringify(credentials));\n  const client = await Client.withUserAuth(credentials.payload);\n  console.log('Verified on Textile API!!');\n  return client;\n};\nexport const getCredentials = async function () {\n  const credentials = JSON.parse(localStorage.getItem('payload'));\n  const threadDB = credentials.threadDbId;\n  const client = Client.withUserAuth(credentials.payload);\n  const threadDb = Uint8Array.from(threadDB);\n  return {\n    client,\n    threadDb\n  };\n};\nexport const checkEmailExists = async function (email) {\n  try {\n    const {\n      threadDb,\n      client\n    } = await getCredentials();\n    const threadId = ThreadID.fromBytes(threadDb);\n    const query = new Where('email').eq(email);\n    const result = await client.find(threadId, 'RegisterUser', query);\n\n    if (result.length === 1) {\n      return {\n        status: false,\n        user: result[0]\n      };\n    }\n\n    return {\n      status: true\n    };\n  } catch (e) {\n    console.log(\"Error:\", e);\n    return {\n      status: false\n    };\n  }\n};\nexport const registerNewUser = async function (did, name, email, signUpMode) {\n  try {\n    console.log(\"mode:\", signUpMode); //generate aes key for the user\n\n    const {\n      threadDb,\n      client\n    } = await getCredentials();\n    const threadId = ThreadID.fromBytes(threadDb);\n    const data = {\n      did: did,\n      name: name,\n      email: email,\n      description: 'nan',\n      phoneNumber: 0,\n      location: 'nan',\n      website: 'nan',\n      birthdate: 'nan',\n      verifiables: {\n        github: {\n          username: 'nan',\n          githubVerified: false\n        },\n        twitter: {\n          username: 'nan',\n          twitterVerified: false\n        }\n      },\n      experience: [{\n        _id: \"-1\"\n      }],\n      signUpMode: signUpMode\n    };\n    const query = new Where('did').eq(did);\n    const result = await client.find(threadId, 'RegisterUser', query);\n\n    if (result.length < 1) {\n      await client.create(threadId, 'RegisterUser', [data]);\n      localStorage.setItem(\"USER\", JSON.stringify(data));\n      return data;\n    }\n\n    console.log(\"User already exists!!\");\n    return false;\n  } catch (err) {\n    console.log(\"err:\", err);\n    return false;\n  }\n};\nexport const getLoginUser = async function (did) {\n  try {\n    const {\n      client,\n      threadDb\n    } = await getCredentials();\n    const query = new Where('did').eq(did);\n    const threadId = ThreadID.fromBytes(threadDb);\n    const result = await client.find(threadId, 'RegisterUser', query);\n\n    if (result.length < 1) {\n      console.log(\"Please register user!\");\n      return null;\n    }\n\n    return result[0];\n  } catch (err) {\n    console.log(\"err:\", err);\n    return null;\n  }\n};\nexport const getAllUsers = async function (did) {\n  try {\n    const {\n      threadDb,\n      client\n    } = await getCredentials();\n    const threadId = ThreadID.fromBytes(threadDb);\n    const registeredUsers = await client.find(threadId, 'RegisterUser', {});\n    let caller;\n    let userArray = [];\n    console.log(\"Registered users:\", registeredUsers);\n\n    for (let i = 0; i < registeredUsers.length; i++) {\n      const result = registeredUsers[i];\n      const value = {\n        name: result.name,\n        email: result.email,\n        did: result.did\n      };\n\n      if (did.toLowerCase() === result.did.toLowerCase()) {\n        caller = value;\n      } else {\n        userArray.push(value);\n      }\n    }\n\n    return {\n      userArray: userArray,\n      caller: caller\n    };\n  } catch (e) {\n    console.log(\"err:\", e);\n    return null;\n  }\n};\nexport const updateInfo = async function (name, email, description, phoneNumber, location, website, birthdate, github, twitter, employer, jobTitle) {\n  const {\n    threadDb,\n    client\n  } = await getCredentials();\n  const threadId = ThreadID.fromBytes(threadDb);\n\n  try {\n    let query = new Where('email').eq(email);\n    let user = await client.find(threadId, 'RegisterUser', query);\n    const verifiables = {\n      github: {\n        username: github,\n        githubVerified: false\n      },\n      twitter: {\n        username: twitter,\n        twitterVerified: false\n      }\n    };\n    const workExperience = {\n      employer: employer,\n      jobTitle: jobTitle\n    };\n    user[0].name = name;\n    user[0].email = email;\n    user[0].description = description;\n    user[0].phoneNumber = phoneNumber;\n    user[0].location = location;\n    user[0].website = website;\n    user[0].birthdate = birthdate;\n    user[0].verifiables = verifiables;\n\n    if (user[0].experience.length === 1 && user[0].experience[0]._id === \"-1\") {\n      user[0].experience = [workExperience];\n    } else {\n      user[0].experience.push(workExperience);\n    }\n\n    await client.save(threadId, 'RegisterUser', [user[0]]);\n    console.log(\"updated!!\");\n    return true;\n  } catch (e) {\n    console.log(\"Error:\", e);\n    return false;\n  }\n};\nexport const updateGithubStatus = async function (email) {\n  const {\n    threadDb,\n    client\n  } = await getCredentials();\n  const threadId = ThreadID.fromBytes(threadDb);\n\n  try {\n    let query = new Where('email').eq(email);\n    let user = await client.find(threadId, 'RegisterUser', query);\n    user[0].verifiables.github.githubVerified = true;\n    await client.save(threadId, 'RegisterUser', [user[0]]);\n    console.log(\"updated!!\");\n    return true;\n  } catch (e) {\n    console.log(\"Error:\", e);\n    return false;\n  }\n};\nexport const updateTwitterStatus = async function (email) {\n  const {\n    threadDb,\n    client\n  } = await getCredentials();\n  const threadId = ThreadID.fromBytes(threadDb);\n\n  try {\n    let query = new Where('email').eq(email);\n    let user = await client.find(threadId, 'RegisterUser', query);\n    user[0].verifiables.twitter.twitterVerified = true;\n    await client.save(threadId, 'RegisterUser', [user[0]]);\n    console.log(\"updated!!\");\n    return true;\n  } catch (e) {\n    console.log(\"Error:\", e);\n    return false;\n  }\n};\n/*\r\nexport const generateCipherKey = function(){\r\n    try {\r\n        const seed = crypto.randomBytes(32).toString()\r\n        return new Promise((resolve)=>{\r\n            const cipherKey = crypto.createHash('sha256').update(seed).digest();\r\n            resolve(cipherKey)\r\n        })\r\n    }catch (err) {\r\n        console.error(\"Error while generating symmetric key:\",err)\r\n        return null\r\n    }\r\n}\r\n*/\n\n/*\r\nexport const encryptData = function(data,cipherKey){\r\n    return new Promise((resolve)=>{\r\n        let iv = crypto.randomBytes(16);\r\n        const cipher = crypto.createCipheriv('aes256', cipherKey, iv);\r\n        const encryptedData= Buffer.concat([\r\n            iv,\r\n            cipher.update(data),\r\n            cipher.final()\r\n        ]);\r\n        resolve(encryptedData)\r\n    })\r\n}\r\n*/\n\n/*\r\nexport const decryptData = async function(encryptedData,cipherKey){\r\n    const iv = encryptedData.slice(0,16)\r\n    encryptedData = encryptedData.slice(16)\r\n    return new Promise((resolve)=>{\r\n        const decipher = crypto.createDecipheriv(\"aes256\",cipherKey,iv)\r\n        const decryptedData = Buffer.concat([decipher.update(encryptedData), decipher.final()]);\r\n        resolve(decryptedData)\r\n    })\r\n}\r\n*/","map":{"version":3,"sources":["D:/identity-managment/lib/threadDb.js"],"names":["crypto","require","Client","Where","ThreadID","io","solveChallenge","identity","Promise","resolve","reject","socket","process","env","NEXT_PUBLIC_MIDDLEWARE_URL","on","publicKey","public","toString","emit","JSON","stringify","pubKey","type","event","data","parse","value","buf","Buffer","from","signed","sign","disconnect","loginUserWithChallenge","id","Error","credentials","localStorage","setItem","client","withUserAuth","payload","console","log","getCredentials","getItem","threadDB","threadDbId","threadDb","Uint8Array","checkEmailExists","email","threadId","fromBytes","query","eq","result","find","length","status","user","e","registerNewUser","did","name","signUpMode","description","phoneNumber","location","website","birthdate","verifiables","github","username","githubVerified","twitter","twitterVerified","experience","_id","create","err","getLoginUser","getAllUsers","registeredUsers","caller","userArray","i","toLowerCase","push","updateInfo","employer","jobTitle","workExperience","save","updateGithubStatus","updateTwitterStatus"],"mappings":"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","sourcesContent":["\r\nconst crypto = require('crypto')\r\nconst { Client, Where, ThreadID } = require('@textile/hub')\r\nconst io = require('socket.io-client');\r\n\r\nexport const solveChallenge = (identity) => {\r\n    return new Promise((resolve, reject) => {\r\n\r\n        const socket = io(process.env.NEXT_PUBLIC_MIDDLEWARE_URL);\r\n        socket.on(\"connect\", () => {\r\n            const publicKey = identity.public.toString();\r\n\r\n            // Send public key to server\r\n            socket.emit('authInit', JSON.stringify({\r\n                pubKey: publicKey,\r\n                type: 'token'\r\n            }));\r\n\r\n            socket.on(\"authMsg\", async (event) => {\r\n                const data = JSON.parse(event)\r\n                switch (data.type) {\r\n                    case 'error': {\r\n                        reject(data.value);\r\n                        break;\r\n                    }\r\n\r\n                    //solve the challenge\r\n                    case 'challenge': {\r\n                        const buf = Buffer.from(data.value)\r\n                        const signed = await identity.sign(buf)\r\n                        socket.emit(\"challengeResp\", signed);\r\n                        break;\r\n                    }\r\n\r\n                    //get the token and store it\r\n                    case 'token': {\r\n                        resolve(data.value)\r\n                        socket.disconnect();\r\n                        break;\r\n                    }\r\n                }\r\n            })\r\n        });\r\n    });\r\n}\r\n\r\nexport const loginUserWithChallenge = async function(id){\r\n    if (!id) {\r\n        throw Error('No user ID found')\r\n    }\r\n\r\n    /** Use the identity to request a new API token when needed */\r\n    const credentials = await solveChallenge(id);\r\n    localStorage.setItem('payload',JSON.stringify(credentials))\r\n    const client = await Client.withUserAuth(credentials.payload)\r\n    console.log('Verified on Textile API!!')\r\n    return client\r\n}\r\n\r\nexport const getCredentials = async function(){\r\n    const credentials = JSON.parse(localStorage.getItem('payload'))\r\n    const threadDB = credentials.threadDbId\r\n    const client = Client.withUserAuth(credentials.payload)\r\n    const threadDb = Uint8Array.from(threadDB)\r\n    return {client, threadDb}\r\n}\r\n\r\nexport const checkEmailExists = async function(email){\r\n    try{\r\n        const {threadDb, client} = await getCredentials()\r\n        const threadId = ThreadID.fromBytes(threadDb)\r\n        const query = new Where('email').eq(email)\r\n        const result = await client.find(threadId, 'RegisterUser', query)\r\n        if (result.length===1){\r\n            return {\r\n                status: false,\r\n                user: result[0]\r\n            }\r\n        }\r\n        return {status:true}\r\n    }catch (e){\r\n        console.log(\"Error:\",e)\r\n        return {status: false}\r\n    }\r\n}\r\n\r\nexport const registerNewUser = async function(did, name, email, signUpMode){\r\n    try {\r\n        console.log(\"mode:\",signUpMode)\r\n        //generate aes key for the user\r\n        const {threadDb, client} = await getCredentials()\r\n        const threadId = ThreadID.fromBytes(threadDb)\r\n        const data = {\r\n            did:did,\r\n            name: name,\r\n            email: email,\r\n            description: 'nan',\r\n            phoneNumber: 0,\r\n            location: 'nan',\r\n            website: 'nan',\r\n            birthdate: 'nan',\r\n            verifiables: {\r\n                github: {\r\n                    username: 'nan',\r\n                    githubVerified: false,\r\n                },\r\n                twitter: {\r\n                    username: 'nan',\r\n                    twitterVerified: false,\r\n                }\r\n            },\r\n            experience: [{_id:\"-1\"}],\r\n            signUpMode: signUpMode\r\n        }\r\n\r\n        const query = new Where('did').eq(did)\r\n        const result = await client.find(threadId, 'RegisterUser', query)\r\n        if (result.length<1){\r\n            await client.create(threadId, 'RegisterUser', [data])\r\n            localStorage.setItem(\"USER\", JSON.stringify(data))\r\n            return data\r\n        }\r\n        console.log(\"User already exists!!\")\r\n        return false\r\n    }catch(err){\r\n        console.log(\"err:\",err)\r\n        return false\r\n    }\r\n}\r\n\r\nexport const getLoginUser = async function(did){\r\n    try {\r\n        const {client, threadDb} = await getCredentials()\r\n        const query = new Where('did').eq(did)\r\n        const threadId = ThreadID.fromBytes(threadDb)\r\n        const result = await client.find(threadId, 'RegisterUser', query)\r\n\r\n        if (result.length<1){\r\n            console.log(\"Please register user!\")\r\n            return null\r\n        }\r\n        return result[0]\r\n    }catch (err) {\r\n        console.log(\"err:\",err)\r\n        return null\r\n    }\r\n}\r\n\r\nexport const getAllUsers = async function(did){\r\n    try {\r\n        const {threadDb, client} = await getCredentials()\r\n        const threadId = ThreadID.fromBytes(threadDb)\r\n        const registeredUsers = await client.find(threadId, 'RegisterUser', {})\r\n        let caller\r\n        let userArray = []\r\n        console.log(\"Registered users:\", registeredUsers)\r\n\r\n        for (let i=0;i<registeredUsers.length;i++){\r\n            const result = registeredUsers[i]\r\n            const value = {\r\n                name: result.name,\r\n                email: result.email,\r\n                did: result.did\r\n            }\r\n            if (did.toLowerCase() === result.did.toLowerCase()) {\r\n                caller = value\r\n            }\r\n            else {\r\n                userArray.push(value)\r\n            }\r\n        }\r\n\r\n        return {\r\n            userArray: userArray,\r\n            caller: caller\r\n        }\r\n    }catch (e){\r\n        console.log(\"err:\",e)\r\n        return null\r\n    }\r\n}\r\n\r\nexport const updateInfo = async function(name,email, description, phoneNumber, location, website, birthdate,\r\n                                         github, twitter, employer, jobTitle ){\r\n    const {threadDb, client} = await getCredentials()\r\n    const threadId = ThreadID.fromBytes(threadDb)\r\n    try{\r\n        let query = new Where('email').eq(email)\r\n        let user = await client.find(threadId, 'RegisterUser', query)\r\n\r\n        const verifiables = {\r\n            github: {\r\n                username: github,\r\n                githubVerified: false,\r\n            },\r\n            twitter: {\r\n                username: twitter,\r\n                twitterVerified: false,\r\n            }\r\n        }\r\n\r\n        const workExperience = {\r\n            employer: employer,\r\n            jobTitle: jobTitle\r\n        }\r\n\r\n        user[0].name = name\r\n        user[0].email = email\r\n        user[0].description = description\r\n        user[0].phoneNumber = phoneNumber\r\n        user[0].location = location\r\n        user[0].website = website\r\n        user[0].birthdate = birthdate\r\n        user[0].verifiables = verifiables\r\n        if (user[0].experience.length ===1 && user[0].experience[0]._id === \"-1\"){\r\n            user[0].experience = [workExperience]\r\n        }else{\r\n            user[0].experience.push(workExperience)\r\n        }\r\n\r\n        await client.save(threadId,'RegisterUser',[user[0]])\r\n        console.log(\"updated!!\")\r\n        return true\r\n    }catch (e) {\r\n        console.log(\"Error:\",e)\r\n        return false\r\n    }\r\n}\r\n\r\nexport const updateGithubStatus = async function(email){\r\n    const {threadDb, client} = await getCredentials()\r\n    const threadId = ThreadID.fromBytes(threadDb)\r\n    try{\r\n        let query = new Where('email').eq(email)\r\n        let user = await client.find(threadId, 'RegisterUser', query)\r\n\r\n        user[0].verifiables.github.githubVerified = true\r\n\r\n        await client.save(threadId,'RegisterUser',[user[0]])\r\n        console.log(\"updated!!\")\r\n        return true\r\n    }catch (e) {\r\n        console.log(\"Error:\",e)\r\n        return false\r\n    }\r\n}\r\n\r\nexport const updateTwitterStatus = async function(email){\r\n    const {threadDb, client} = await getCredentials()\r\n    const threadId = ThreadID.fromBytes(threadDb)\r\n    try{\r\n        let query = new Where('email').eq(email)\r\n        let user = await client.find(threadId, 'RegisterUser', query)\r\n\r\n        user[0].verifiables.twitter.twitterVerified = true\r\n\r\n        await client.save(threadId,'RegisterUser',[user[0]])\r\n        console.log(\"updated!!\")\r\n        return true\r\n    }catch (e) {\r\n        console.log(\"Error:\",e)\r\n        return false\r\n    }\r\n}\r\n\r\n/*\r\nexport const generateCipherKey = function(){\r\n    try {\r\n        const seed = crypto.randomBytes(32).toString()\r\n        return new Promise((resolve)=>{\r\n            const cipherKey = crypto.createHash('sha256').update(seed).digest();\r\n            resolve(cipherKey)\r\n        })\r\n    }catch (err) {\r\n        console.error(\"Error while generating symmetric key:\",err)\r\n        return null\r\n    }\r\n}\r\n*/\r\n\r\n/*\r\nexport const encryptData = function(data,cipherKey){\r\n    return new Promise((resolve)=>{\r\n        let iv = crypto.randomBytes(16);\r\n        const cipher = crypto.createCipheriv('aes256', cipherKey, iv);\r\n        const encryptedData= Buffer.concat([\r\n            iv,\r\n            cipher.update(data),\r\n            cipher.final()\r\n        ]);\r\n        resolve(encryptedData)\r\n    })\r\n}\r\n*/\r\n\r\n/*\r\nexport const decryptData = async function(encryptedData,cipherKey){\r\n    const iv = encryptedData.slice(0,16)\r\n    encryptedData = encryptedData.slice(16)\r\n    return new Promise((resolve)=>{\r\n        const decipher = crypto.createDecipheriv(\"aes256\",cipherKey,iv)\r\n        const decryptedData = Buffer.concat([decipher.update(encryptedData), decipher.final()]);\r\n        resolve(decryptedData)\r\n    })\r\n}\r\n*/\r\n"]},"metadata":{},"sourceType":"module"}